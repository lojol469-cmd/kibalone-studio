<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé¨ Test Personnage Anim√© - Kibalone</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            height: 100vh;
        }
        
        #viewport {
            flex: 1;
            position: relative;
        }
        
        #controls {
            width: 350px;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            overflow-y: auto;
        }
        
        h1 {
            font-size: 24px;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #00f, #f0f);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .btn {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        #status {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .success { color: #38ef7d; }
        .error { color: #f5576c; }
        .info { color: #667eea; }
        
        #info {
            margin-top: 20px;
            font-size: 12px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="viewport"></div>
        <div id="controls">
            <h1>üé¨ Test Personnage Anim√©</h1>
            
            <button class="btn btn-primary" onclick="createCharacter()">
                üé® Cr√©er Personnage
            </button>
            
            <button class="btn btn-success" onclick="animateRun()" id="btnRun" disabled>
                üèÉ Animation Course
            </button>
            
            <button class="btn btn-warning" onclick="animateJump()" id="btnJump" disabled>
                ü¶ò Animation Saut
            </button>
            
            <button class="btn btn-primary" onclick="testOrchestration()">
                üéØ Test Orchestration
            </button>
            
            <div id="status">
                <div class="info">üëÜ Cliquez sur "Cr√©er Personnage" pour commencer</div>
            </div>
            
            <div id="info">
                <strong>Architecture Dual Backend:</strong><br>
                ‚Ä¢ Three.js Backend (port 11005): Manipulation rapide<br>
                ‚Ä¢ Kibali Orchestrator (port 11000): IA intelligente<br>
                ‚Ä¢ 48 outils disponibles pour cr√©ation 3D
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script>
        let scene, camera, renderer, character;
        let characterId = null;
        let mixer = null;
        let clock = new THREE.Clock();

        // Initialisation Three.js
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 1, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth - 350, window.innerHeight);
            document.getElementById('viewport').appendChild(renderer.domElement);
            
            // Lumi√®res
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);
            
            // Sol
            const gridHelper = new THREE.GridHelper(20, 20);
            scene.add(gridHelper);
            
            // Animation loop
            animate();
            
            updateStatus('‚úÖ Scene Three.js initialis√©e', 'success');
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            
            renderer.render(scene, camera);
        }

        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.innerHTML = `<div class="${type}">${message}</div>`;
        }

        // Cr√©er personnage depuis backend Three.js
        async function createCharacter() {
            updateStatus('‚è≥ Cr√©ation du personnage...', 'info');
            
            try {
                const response = await fetch('http://localhost:11005/api/create-character', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: 'personnage h√©ro√Øque' })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    characterId = data.id;
                    
                    // Construire le personnage depuis les donn√©es
                    character = buildCharacterFromData(data.geometry);
                    scene.add(character);
                    
                    document.getElementById('btnRun').disabled = false;
                    document.getElementById('btnJump').disabled = false;
                    
                    updateStatus(`‚úÖ Personnage cr√©√©! ID: ${characterId}<br>Parts: ${data.parts.join(', ')}`, 'success');
                } else {
                    updateStatus('‚ùå Erreur cr√©ation personnage', 'error');
                }
            } catch (error) {
                updateStatus(`‚ùå Erreur: ${error.message}`, 'error');
            }
        }

        // Construire le personnage depuis les donn√©es JSON
        function buildCharacterFromData(data) {
            const group = new THREE.Group();
            group.name = data.name;
            
            if (data.children) {
                data.children.forEach(childData => {
                    const mesh = createMeshFromData(childData);
                    if (mesh) group.add(mesh);
                });
            }
            
            return group;
        }

        function createMeshFromData(data) {
            let geometry;
            
            // Cr√©er la g√©om√©trie selon le type
            switch (data.geometry.type) {
                case 'BoxGeometry':
                    const bp = data.geometry.parameters;
                    geometry = new THREE.BoxGeometry(bp.width, bp.height, bp.depth);
                    break;
                case 'SphereGeometry':
                    const sp = data.geometry.parameters;
                    geometry = new THREE.SphereGeometry(sp.radius, sp.widthSegments, sp.heightSegments);
                    break;
                case 'CylinderGeometry':
                    const cp = data.geometry.parameters;
                    geometry = new THREE.CylinderGeometry(cp.radiusTop, cp.radiusBottom, cp.height, cp.radialSegments);
                    break;
                default:
                    return null;
            }
            
            // Cr√©er le mat√©riau
            const material = new THREE.MeshStandardMaterial({
                color: data.material.color
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = data.name;
            mesh.position.set(data.position.x, data.position.y, data.position.z);
            mesh.rotation.set(data.rotation._x, data.rotation._y, data.rotation._z);
            mesh.scale.set(data.scale.x, data.scale.y, data.scale.z);
            
            return mesh;
        }

        // Animation course
        async function animateRun() {
            if (!characterId) return;
            
            updateStatus('üèÉ Lancement animation course...', 'info');
            
            try {
                const response = await fetch('http://localhost:11005/api/create-animation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        objectId: characterId,
                        animationType: 'run'
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Animer le personnage
                    const startPos = data.keyframes[0].position;
                    const endPos = data.keyframes[1].position;
                    
                    animatePosition(character, startPos, endPos, data.duration / data.fps);
                    
                    updateStatus(`‚úÖ Animation course d√©marr√©e (${data.duration} frames)`, 'success');
                } else {
                    updateStatus('‚ùå Erreur animation', 'error');
                }
            } catch (error) {
                updateStatus(`‚ùå Erreur: ${error.message}`, 'error');
            }
        }

        // Animation saut
        async function animateJump() {
            if (!characterId) return;
            
            updateStatus('ü¶ò Lancement animation saut...', 'info');
            
            try {
                const response = await fetch('http://localhost:11005/api/create-animation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        objectId: characterId,
                        animationType: 'jump'
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Animation avec 3 keyframes (0, peak, 0)
                    animateJumpSequence(character, data.keyframes, data.duration / data.fps);
                    
                    updateStatus(`‚úÖ Animation saut d√©marr√©e (${data.duration} frames)`, 'success');
                } else {
                    updateStatus('‚ùå Erreur animation', 'error');
                }
            } catch (error) {
                updateStatus(`‚ùå Erreur: ${error.message}`, 'error');
            }
        }

        // Helper animation position
        function animatePosition(object, start, end, duration) {
            const startTime = Date.now();
            
            function update() {
                const elapsed = (Date.now() - startTime) / 1000;
                const progress = Math.min(elapsed / duration, 1);
                
                object.position.x = start.x + (end.x - start.x) * progress;
                object.position.y = start.y + (end.y - start.y) * progress;
                object.position.z = start.z + (end.z - start.z) * progress;
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            
            update();
        }

        // Helper animation saut
        function animateJumpSequence(object, keyframes, duration) {
            const startTime = Date.now();
            const halfDuration = duration / 2;
            
            function update() {
                const elapsed = (Date.now() - startTime) / 1000;
                
                if (elapsed < halfDuration) {
                    // Monte
                    const progress = elapsed / halfDuration;
                    object.position.y = keyframes[0].position.y + (keyframes[1].position.y - keyframes[0].position.y) * progress;
                } else if (elapsed < duration) {
                    // Descend
                    const progress = (elapsed - halfDuration) / halfDuration;
                    object.position.y = keyframes[1].position.y + (keyframes[2].position.y - keyframes[1].position.y) * progress;
                } else {
                    object.position.y = keyframes[2].position.y;
                    return;
                }
                
                requestAnimationFrame(update);
            }
            
            update();
        }

        // Test orchestration
        async function testOrchestration() {
            updateStatus('üéØ Test orchestration...', 'info');
            
            try {
                const response = await fetch('http://localhost:11000/api/orchestrate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: 'cr√©e un personnage qui court et saute',
                        execute: true
                    })
                });
                
                const data = await response.json();
                
                if (data.understood) {
                    let msg = `‚úÖ Orchestration r√©ussie!<br>`;
                    msg += `‚Ä¢ Compris: ${data.understood}<br>`;
                    msg += `‚Ä¢ √âtapes: ${data.plan.steps.length}<br>`;
                    msg += `‚Ä¢ Complexit√©: ${data.plan.complexity}<br>`;
                    
                    if (data.execution) {
                        msg += `‚Ä¢ Dur√©e: ${data.execution.total_duration || 0}s<br>`;
                        msg += `‚Ä¢ Succ√®s: ${data.execution.success}`;
                    }
                    
                    updateStatus(msg, 'success');
                } else {
                    updateStatus('‚ùå Orchestration √©chou√©e', 'error');
                }
            } catch (error) {
                updateStatus(`‚ùå Erreur: ${error.message}`, 'error');
            }
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = (window.innerWidth - 350) / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth - 350, window.innerHeight);
        });

        // Init
        init();
    </script>
</body>
</html>
