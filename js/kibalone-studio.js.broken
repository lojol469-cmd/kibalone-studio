// Kibalone Studio - AI-Powered 3D Animation Interface
// Main JavaScript Controller

class KibaloneStudio {
    constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.objects = [];
        this.currentFrame = 0;
        this.totalFrames = 120;
        this.isPlaying = false;
        this.fps = 30;
        
        this.init();
    }

    init() {
        this.initThreeJS();
        this.initEventListeners();
        this.animate();
        console.log('üöÄ Kibalone Studio initialis√©');
        
        // Auto-load test reconstruction
        this.autoLoadTestReconstruction();
        
        // Initialiser la s√©lection
        this.selectedObject = null;
    }
    
    async autoLoadTestReconstruction() {
        // Attendre 1 seconde pour que l'interface soit pr√™te
        setTimeout(async () => {
            try {
                await loadTestReconstruction();
            } catch (error) {
                console.warn('‚ö†Ô∏è Impossible de charger la reconstruction test');
            }
        }, 1000);
    }

    initThreeJS() {
        const canvas = document.getElementById('canvas3d');
        
        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x0f0f1e);
        
        // Camera
        this.camera = new THREE.PerspectiveCamera(
            75,
            canvas.clientWidth / canvas.clientHeight,
            0.1,
            1000
        );
        this.camera.position.set(5, 5, 5);
        this.camera.lookAt(0, 0, 0);
        
        // Renderer
        this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        this.renderer.shadowMap.enabled = true;
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040, 2);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        this.scene.add(directionalLight);
        
        // Grid
        const gridHelper = new THREE.GridHelper(20, 20, 0x00d4ff, 0x2d4059);
        this.scene.add(gridHelper);
        
        // Axes Helper
        const axesHelper = new THREE.AxesHelper(5);
        this.scene.add(axesHelper);
        
        // Controls (basic mouse rotation)
        this.initControls();
    }

    initControls() {
        const canvas = document.getElementById('canvas3d');
        let isDragging = false;
        let mouseDownPos = { x: 0, y: 0 };
        let previousMousePosition = { x: 0, y: 0 };

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            mouseDownPos = { x: e.clientX, y: e.clientY };
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                this.camera.position.x += deltaX * 0.01;
                this.camera.position.y -= deltaY * 0.01;
                this.camera.lookAt(0, 0, 0);

                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            // D√©tecter si c'√©tait un clic (pas un drag)
            const deltaX = Math.abs(e.clientX - mouseDownPos.x);
            const deltaY = Math.abs(e.clientY - mouseDownPos.y);
            
            if (deltaX < 5 && deltaY < 5) {
                // C'√©tait un clic, pas un drag
                this.handleObjectSelection(e);
            }
            
            isDragging = false;
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomSpeed = 0.1;
            const direction = e.deltaY > 0 ? 1 : -1;
            
            this.camera.position.multiplyScalar(1 + direction * zoomSpeed);
        });
    }

    handleObjectSelection(event) {
        const canvas = document.getElementById('canvas3d');
        const rect = canvas.getBoundingClientRect();
        
        // Coordonn√©es normalis√©es
        const mouse = new THREE.Vector2(
            ((event.clientX - rect.left) / rect.width) * 2 - 1,
            -((event.clientY - rect.top) / rect.height) * 2 + 1
        );
        
        // Raycaster pour d√©tecter l'objet cliqu√©
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, this.camera);
        
        // Chercher uniquement dans les objets cr√©√©s (pas grid, lumi√®res, etc.)
        const intersects = raycaster.intersectObjects(this.objects, true);
        
        // D√©s√©lectionner l'ancien objet
        if (this.selectedObject) {
            if (this.selectedObject.material.emissive) {
                this.selectedObject.material.emissive.setHex(0x000000);
            }
        }
        
        if (intersects.length > 0) {
            // S√©lectionner le nouvel objet
            this.selectedObject = intersects[0].object;
            
            // Highlight visuel
            if (this.selectedObject.material.emissive) {
                this.selectedObject.material.emissive.setHex(0x00ff88);
            } else if (this.selectedObject.material.color) {
                // Pour les PointsMaterial
                const originalColor = this.selectedObject.material.color.getHex();
                this.selectedObject.userData.originalColor = originalColor;
            }
            
            console.log('üéØ Objet s√©lectionn√©:', this.selectedObject.userData.name || 'Sans nom');
            updateSelectionInfo(this.selectedObject);
        } else {
            this.selectedObject = null;
            updateSelectionInfo(null);
        }
    }

    deleteSelectedObject() {
        if (!this.selectedObject) {
            addChatMessage('ai', '‚ö†Ô∏è Aucun objet s√©lectionn√©. Cliquez sur un objet pour le s√©lectionner.');
            return;
        }
        
        const name = this.selectedObject.userData.name || 'Objet';
        
        // Retirer de la sc√®ne
        this.scene.remove(this.selectedObject);
        
        // Retirer du tableau des objets
        const index = this.objects.indexOf(this.selectedObject);
        if (index > -1) {
            this.objects.splice(index, 1);
        }
        
        // Lib√©rer la m√©moire
        if (this.selectedObject.geometry) {
            this.selectedObject.geometry.dispose();
        }
        if (this.selectedObject.material) {
            this.selectedObject.material.dispose();
        }
        
        console.log('üóëÔ∏è Objet supprim√©:', name);
        addChatMessage('ai', `üóëÔ∏è "${name}" supprim√© de la sc√®ne`);
        
        this.selectedObject = null;
        updateSelectionInfo(null);
    }

    initEventListeners() {
        window.addEventListener('resize', () => this.onWindowResize());
    }

    onWindowResize() {
        const canvas = document.getElementById('canvas3d');
        this.camera.aspect = canvas.clientWidth / canvas.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);
    }

    animate() {
        requestAnimationFrame(() => this.animate());
        
        if (this.isPlaying) {
            this.currentFrame++;
            if (this.currentFrame > this.totalFrames) {
                this.currentFrame = 0;
            }
            this.updateFrame();
        }
        
        this.renderer.render(this.scene, this.camera);
    }

    updateFrame() {
        document.getElementById('current-frame').textContent = this.currentFrame;
        document.getElementById('timeline-frame').textContent = this.currentFrame;
        
        const progress = (this.currentFrame / this.totalFrames) * 100;
        document.getElementById('timeline-progress').style.width = progress + '%';
    }

    // AI Functions
    async processAICommand(prompt) {
        addChatMessage('user', prompt);
        const loadingMsg = addChatMessage('ai', 'ü§ñ Kibali analyse votre demande...');

        try {
            // Appel √† l'API Kibali
            const response = await fetch('http://localhost:5000/api/chat', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    message: prompt,
                    context: 'creation',
                    history: this.getChatHistory()
                })
            });

            const data = await response.json();
            
            console.log('üì• R√©ponse API re√ßue:', data);
            
            if (data.success) {
                // Cr√©e le message AI AVANT executeAICommand
                const aiMsg = addChatMessage('ai', data.response || 'Compris ! Je cr√©e √ßa pour vous...');
                
                // Retire le message de chargement
                if (loadingMsg && loadingMsg.parentNode) {
                    loadingMsg.parentNode.removeChild(loadingMsg);
                }
                
                // Analyse le prompt avec Kibali
                const analysis = await this.analyzePromptWithKibali(prompt);
                console.log('üîç Analyse:', analysis);
                this.executeAICommand(analysis, prompt, data.response);
            } else {
                // Retire le message de chargement
                if (loadingMsg && loadingMsg.parentNode) {
                    loadingMsg.parentNode.removeChild(loadingMsg);
                }
                addChatMessage('ai', '‚ùå Erreur: ' + data.error);
            }
        } catch (error) {
            console.error('Erreur Kibali API:', error);
            
            // Cr√©e le message AI pour le fallback AVANT executeAICommand
            const fallbackMsg = addChatMessage('ai', '‚ö†Ô∏è Kibali offline, mode local activ√©');
            
            // Retire le message de chargement
            if (loadingMsg && loadingMsg.parentNode) {
                loadingMsg.parentNode.removeChild(loadingMsg);
            }
            
            // Fallback sur analyse locale
            const command = this.analyzePrompt(prompt);
            console.log('üîç Analyse locale:', command);
            this.executeAICommand(command, prompt, null);
        }
    }

    async analyzePromptWithKibali(prompt) {
        try {
            const response = await fetch('http://localhost:5000/api/analyze-prompt', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    prompt: prompt,
                    context: 'general'
                })
            });

            const data = await response.json();
            return data.success ? data : this.analyzePrompt(prompt);
        } catch (error) {
            return this.analyzePrompt(prompt);
        }
    }

    getChatHistory() {
        const messages = document.querySelectorAll('.chat-messages .message');
        const history = [];
        messages.forEach(msg => {
            try {
                const role = msg.classList.contains('user') ? 'user' : 'assistant';
                const contentDiv = msg.querySelector('div');
                if (contentDiv && contentDiv.textContent) {
                    const content = contentDiv.textContent.trim();
                    if (content && !content.includes('ü§ñ Kibali analyse')) {
                        history.push({ role, content });
                    }
                }
            } catch (e) {
                console.warn('Erreur parsing message:', e);
            }
        });
        return history.slice(-10); // 10 derniers messages
    }

    analyzePrompt(prompt) {
        prompt = prompt.toLowerCase();
        console.log('üîç analyzePrompt - Analyse:', prompt);
        
        // D√©tection reconstruction 3D
        if (prompt.includes('reconstruction') || 
            prompt.includes('scanner') || 
            prompt.includes('scan 3d') ||
            prompt.includes('multi-angle') ||
            prompt.includes('midas') ||
            (prompt.includes('test') && (prompt.includes('ch√¢teau') || prompt.includes('chateau') || prompt.includes('3d')))) {
            console.log('   ‚Üí RECONSTRUCTION_3D');
            return 'RECONSTRUCTION_3D';
        } else if (prompt.includes('personnage') || prompt.includes('character')) {
            console.log('   ‚Üí CREATE_CHARACTER');
            return 'CREATE_CHARACTER';
        } else if (prompt.includes('environnement') || prompt.includes('environment')) {
            return 'CREATE_ENVIRONMENT';
        } else if (prompt.includes('cam√©ra') || prompt.includes('camera')) {
            return 'CONTROL_CAMERA';
        } else if (prompt.includes('anime') || prompt.includes('animation')) {
            return 'CREATE_ANIMATION';
        } else if (prompt.includes('lumi√®re') || prompt.includes('light')) {
            return 'ADD_LIGHT';
        } else if (prompt.includes('objet') || prompt.includes('object')) {
            return 'CREATE_OBJECT';
        } else {
            return 'GENERAL';
        }
    }

    executeAICommand(command, prompt, kibaliResponse) {
        console.log('üé¨ executeAICommand appel√©:', {command, prompt, kibaliResponse});
        const lastMessage = document.querySelector('.chat-messages .message.ai:last-child');
        
        // V√©rifie que le message existe
        if (!lastMessage) {
            console.warn('‚ö†Ô∏è Pas de message AI trouv√©, cr√©ation...');
            const newMsg = addChatMessage('ai', kibaliResponse || 'Compris !');
        }
        
        const targetMessage = document.querySelector('.chat-messages .message.ai:last-child');
        
        console.log('üîÄ Switch sur commande:', command.intent || command);
        
        switch(command.intent || command) {
            case 'RECONSTRUCTION_3D':
            case 'reconstruction_3d':
                console.log('‚úÖ RECONSTRUCTION_3D d√©tect√©, lancement test automatique');
                runTestReconstruction();
                if (targetMessage) {
                    targetMessage.querySelector('div').innerHTML = `ü§ñ Lancement de la reconstruction 3D test...\n‚è≥ Traitement en cours...`;
                }
                break;
                
            case 'CREATE_CHARACTER':
            case 'create_character':
                console.log('‚úÖ CREATE_CHARACTER d√©tect√©, appel createCharacterFromPromptKibali');
                this.createCharacterFromPromptKibali(prompt);
                if (targetMessage) {
                    targetMessage.querySelector('div').innerHTML = `‚úÖ Personnage cr√©√© !<br><small>Il est maintenant dans la sc√®ne.</small>`;
                }
                break;
                
            case 'CREATE_ENVIRONMENT':
            case 'create_environment':
                this.createEnvironmentFromPrompt(prompt);
                if (targetMessage) {
                    targetMessage.querySelector('div').innerHTML = `üåç Environnement cr√©√© !`;
                }
                break;
                
            case 'CONTROL_CAMERA':
            case 'camera':
                this.controlCameraFromPromptKibali(prompt);
                if (targetMessage) {
                    targetMessage.querySelector('div').innerHTML = `üé• Cam√©ra ajust√©e !`;
                }
                break;
                
            case 'CREATE_ANIMATION':
            case 'ANIMATE':
            case 'animate':
                this.createAnimationFromPromptKibali(prompt);
                if (targetMessage) {
                    targetMessage.querySelector('div').innerHTML = `‚ñ∂Ô∏è Animation cr√©√©e ! Appuyez sur Play.`;
                }
                break;
                
            case 'ADD_LIGHT':
            case 'light':
                this.addLightFromPrompt(prompt);
                if (targetMessage) {
                    targetMessage.querySelector('div').innerHTML = `üí° Lumi√®re ajout√©e !`;
                }
                break;
                
            case 'CREATE_OBJECT':
            case 'create_object':
            case 'create':
                this.createObjectFromPromptKibali(prompt);
                if (!kibaliResponse) lastMessage.innerHTML = `üì¶ Objet cr√©√© par Kibali !`;
                break;
                
            default:
                if (!kibaliResponse) {
                    lastMessage.innerHTML = `Kibali peut vous aider √†:<br>
                        - Cr√©er des personnages, objets, environnements<br>
                        - Contr√¥ler la cam√©ra<br>
                        - Animer des √©l√©ments<br>
                        - Ajouter des lumi√®res<br>
                        Que voulez-vous faire ?`;
                }
        }
        
        this.updateObjectCount();
    }

    async createCharacterFromPromptKibali(prompt) {
        try {
            addChatMessage('system', 'üé® Cr√©ation du personnage avec TripoSR...');
            
            // PRIORIT√â 1: Utilise TripoSR pour des mod√®les r√©alistes
            const triposrSuccess = await this.createWithTripoSR(prompt);
            
            if (triposrSuccess) {
                addChatMessage('system', `‚úÖ Personnage cr√©√© et visible dans la sc√®ne !`);
                return;
            }
            
            // FALLBACK: M√©thodes alternatives
            addChatMessage('system', '‚ö†Ô∏è TripoSR indisponible, mode fallback...');
            const method = this.detectGenerationMethod(prompt);
            console.log(`üéØ M√©thode fallback: ${method}`);
            
            if (method === 'grease-pencil') {
                await this.createGreasePencilDrawing(prompt);
            } else if (method === 'advanced' || method === 'blender-style') {
                await this.createAdvanced3D(prompt, method);
            } else {
                this.createCharacterDirect(prompt);
            }
            
            addChatMessage('system', `‚úÖ Personnage cr√©√© avec m√©thode: ${method}`);
            
        } catch (error) {
            console.error('Erreur cr√©ation:', error);
            addChatMessage('system', '‚ö†Ô∏è Erreur de cr√©ation');
        }
    }

    async createWithTripoSR(prompt) {
        /**
         * Cr√©e un mod√®le 3D r√©aliste avec Meshy ou fallback TripoSR
         * Retourne true si succ√®s, false sinon
         */
        console.log('üéØ Tentative de cr√©ation photor√©aliste:', prompt);
        
        // Essaie d'abord Meshy (photor√©aliste cloud)
        try {
            const meshyResponse = await fetch('http://localhost:5003/api/text-to-3d-meshy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt })
            });
            
            if (meshyResponse.ok) {
                const meshyData = await meshyResponse.json();
                
                if (meshyData.success && meshyData.model_url) {
                    console.log('‚úÖ Mod√®le Meshy en cours de t√©l√©chargement...');
                    
                    // Charge le GLB depuis Meshy
                    const loader = new THREE.GLTFLoader();
                    
                    return new Promise((resolve) => {
                        loader.load(
                            meshyData.model_url,
                            (gltf) => {
                                const model = gltf.scene;
                                model.position.set(0, 0, 2);
                                model.scale.set(1.5, 1.5, 1.5);
                                model.userData.name = prompt;
                                model.userData.method = 'meshy-ai';
                                
                                this.scene.add(model);
                                this.objects.push(model);
                                this.updateObjectCount();
                                
                                console.log('‚úÖ Mod√®le photor√©aliste Meshy charg√©!');
                                this.focusOnObject(model);
                                resolve(true);
                            },
                            undefined,
                            (error) => {
                                console.error('‚ùå Erreur chargement GLB:', error);
                                resolve(false);
                            }
                        );
                    });
                }
            }
        } catch (meshyError) {
            console.log('‚ö†Ô∏è Meshy non disponible:', meshyError.message);
        }
        
        // Fallback: TripoSR local
        try {
            const response = await fetch('http://localhost:5001/api/text-to-3d-triposr', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ prompt })
            });
            
            const data = await response.json();
            
            if (data.success && data.code) {
                console.log('‚úÖ Mod√®le TripoSR re√ßu!');
                console.log(`   - Type: ${data.model_type || 'N/A'}`);
                console.log(`   - Vertices: ${data.vertices_count}`);
                console.log(`   - Faces: ${data.faces_count}`);
                console.log(`   - M√©thode: ${data.method}`);
                
                // Ex√©cute le code pour cr√©er l'objet
                const character = eval(data.code);
                
                if (character && (character.type === 'Group' || character.isObject3D)) {
                    character.userData.name = prompt;
                    character.userData.method = data.method || 'triposr';
                    character.userData.model_type = data.model_type;
                    
                    // Position le mod√®le au centre, l√©g√®rement devant
                    character.position.set(0, 0, 2);
                    
                    // Scale pour √™tre s√ªr qu'il soit visible
                    character.scale.set(1.5, 1.5, 1.5);
                    
                    this.scene.add(character);
                    this.objects.push(character);
                    this.updateObjectCount();
                    
                    // Zoom la cam√©ra sur le mod√®le
                    this.focusOnObject(character);
                    
                    console.log('‚úÖ Mod√®le ajout√© √† la sc√®ne!');
                    console.log(`üìä Sc√®ne: ${this.scene.children.length} objets, Array: ${this.objects.length} objets`);
                    console.log(`üìç Position: ${character.position.x}, ${character.position.y}, ${character.position.z}`);
                    console.log(`üìè Scale: ${character.scale.x}`);
                    return true;
                } else {
                    console.error('‚ùå Le code ne retourne pas un THREE.Group valide');
                    console.error('Type re√ßu:', character ? character.type : 'null');
                    return false;
                }
            } else {
                console.warn('‚ö†Ô∏è TripoSR API error:', data.error);
                return false;
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è TripoSR non disponible:', error.message);
            return false;
        }
    }

    detectGenerationMethod(prompt) {
        /**
         * D√©tecte la m√©thode de g√©n√©ration selon le prompt
         */
        const promptLower = prompt.toLowerCase();
        
        // Grease Pencil: mots-cl√©s de dessin
        if (promptLower.match(/(dessine|trace|esquisse|croquis|sketch|ligne|trait)/)) {
            return 'grease-pencil';
        }
        
        // Blender style: complexit√©, r√©alisme
        if (promptLower.match(/(complexe|d√©taill√©|r√©aliste|realistic|avanc√©|blender)/)) {
            return 'blender-style';
        }
        
        // Advanced: anatomie, personnages d√©taill√©s
        if (promptLower.match(/(guerrier|h√©ros|personnage|robot|humain|cr√©ature|avec.*armure|avec.*√©p√©e)/)) {
            return 'advanced';
        }
        
        // Default: simple procedural
        return 'simple';
    }

    async createAdvanced3D(prompt, method) {
        /**
         * Utilise l'endpoint /api/text-to-3d avec m√©thode avanc√©e
         */
        console.log(`üöÄ Cr√©ation avanc√©e: ${prompt} (m√©thode: ${method})`);
        
        try {
            const response = await fetch('http://localhost:5000/api/text-to-3d', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({prompt, method})
            });
            
            const data = await response.json();
            
            if (data.success && data.code) {
                console.log('‚úÖ Code JavaScript re√ßu:', data.code.substring(0, 100) + '...');
                
                // Ex√©cute le code pour cr√©er l'objet
                const character = eval(data.code);
                
                if (character && character.type === 'Group') {
                    character.userData.name = prompt;
                    character.userData.method = data.method;
                    this.scene.add(character);
                    this.objects.push(character);
                    this.updateObjectCount();
                    console.log('‚úÖ Objet avanc√© ajout√© √† la sc√®ne');
                } else {
                    console.error('‚ùå Le code ne retourne pas un THREE.Group valide');
                    console.log('üîÑ Fallback vers cr√©ation directe');
                    this.createCharacterDirect(prompt);
                }
            } else {
                console.error('‚ùå Erreur API:', data.error);
                console.log('üîÑ Fallback vers cr√©ation directe');
                this.createCharacterDirect(prompt);
            }
        } catch (error) {
            console.error('‚ùå Erreur cr√©ation avanc√©e:', error);
            console.log('üîÑ Fallback vers cr√©ation directe');
            this.createCharacterDirect(prompt);
        }
    }

    async createGreasePencilDrawing(prompt) {
        /**
         * Cr√©e un dessin Grease Pencil via l'API
         */
        console.log(`‚úèÔ∏è Dessin Grease Pencil: ${prompt}`);
        
        try {
            const response = await fetch('http://localhost:5000/api/grease-pencil', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({prompt})
            });
            
            const data = await response.json();
            
            if (data.success && data.code) {
                console.log('‚úÖ Code dessin re√ßu:', data.code.substring(0, 100) + '...');
                
                // Ex√©cute le code pour cr√©er le dessin
                const drawing = eval(data.code);
                
                if (drawing && drawing.type === 'Group') {
                    drawing.userData.name = prompt;
                    drawing.userData.method = 'grease-pencil';
                    this.scene.add(drawing);
                    this.objects.push(drawing);
                    this.updateObjectCount();
                    console.log('‚úÖ Dessin ajout√© √† la sc√®ne');
                } else {
                    console.error('‚ùå Le code ne retourne pas un THREE.Group valide');
                    console.log('üîÑ Fallback vers cr√©ation directe');
                    this.createCharacterDirect(prompt);
                }
            } else {
                console.error('‚ùå Erreur API:', data.error);
                console.log('üîÑ Fallback vers cr√©ation directe');
                this.createCharacterDirect(prompt);
            }
        } catch (error) {
            console.error('‚ùå Erreur dessin Grease Pencil:', error);
            console.log('üîÑ Fallback vers cr√©ation directe');
            this.createCharacterDirect(prompt);
        }
    }

    createCharacterDirect(prompt) {
        /**
         * Cr√©ation via JSON - m√©thode animation.git !
         */
        console.log('üöÄ createCharacterDirect - Cr√©ation JSON:', prompt);
        console.log('üìä Sc√®ne avant ajout - Objets:', this.scene.children.length);
        
        // G√©n√®re le JSON structure
        const jsonStructure = this.generateJSONFromPrompt(prompt);
        console.log('üìã JSON g√©n√©r√©:', JSON.stringify(jsonStructure, null, 2));
        
        // Construit depuis le JSON
        console.log('üî® Construction depuis JSON...');
        const character = this.buildFromJSON(jsonStructure);
        console.log('üë§ Personnage construit:', character);
        console.log('   - Type:', character.type);
        console.log('   - Enfants:', character.children.length);
        
        // Ajoute √† la sc√®ne
        character.userData.name = prompt;
        console.log('‚ûï Ajout √† la sc√®ne...');
        this.scene.add(character);
        this.objects.push(character);
        
        console.log('‚úÖ Personnage ajout√© √† la sc√®ne!');
        console.log('üìä Sc√®ne apr√®s ajout - Objets:', this.scene.children.length);
        console.log('üìç Position:', character.position);
        console.log('üéØ Objects array:', this.objects.length);
        
        this.updateObjectCount();
        
        return character;
    }

    generateJSONFromPrompt(prompt) {
        /**
         * G√©n√®re JSON depuis prompt - style animation.git
         */
        const promptLower = prompt.toLowerCase();
        
        let jsonStructure = { objects: [], animations: [] };
        
        if (promptLower.includes('robot')) {
            jsonStructure.objects = [
                {type: 'box', size: [0.8, 1.2, 0.6], position: [0, 1.5, 0], rotation: [0, 0, 0], color: '#888888'},
                {type: 'box', size: [0.6, 0.6, 0.6], position: [0, 2.5, 0], rotation: [0, 0, 0], color: '#AAAAAA'},
                {type: 'sphere', radius: 0.1, position: [-0.2, 2.5, 0.35], rotation: [0, 0, 0], color: '#00FFFF'},
                {type: 'sphere', radius: 0.1, position: [0.2, 2.5, 0.35], rotation: [0, 0, 0], color: '#00FFFF'}
            ];
        } else if (promptLower.includes('guerrier') || promptLower.includes('h√©ro') || promptLower.includes('knight')) {
            jsonStructure.objects = [
                {type: 'box', size: [0.7, 1.3, 0.4], position: [0, 1.5, 0], rotation: [0, 0, 0], color: '#8B4513'},
                {type: 'box', size: [0.75, 0.8, 0.45], position: [0, 1.7, 0], rotation: [0, 0, 0], color: '#C0C0C0'},
                {type: 'sphere', radius: 0.3, position: [0, 2.4, 0], rotation: [0, 0, 0], color: '#FFDBA'},
                {type: 'sphere', radius: 0.35, position: [0, 2.5, 0], rotation: [0, 0, 0], color: '#FFD700'}
            ];
        } else {
            jsonStructure.objects = [
                {type: 'box', size: [0.6, 1.2, 0.3], position: [0, 1.2, 0], rotation: [0, 0, 0], color: '#4488FF'},
                {type: 'sphere', radius: 0.25, position: [0, 2.0, 0], rotation: [0, 0, 0], color: '#FFCC88'}
            ];
        }
        
        return jsonStructure;
    }

    buildFromJSON(jsonStructure) {
        /**
         * Construit Three.js depuis JSON - logique animation.git
         */
        console.log('üèóÔ∏è buildFromJSON appel√© avec:', jsonStructure);
        const group = new THREE.Group();
        
        console.log('üîÑ Parcours des objets JSON:', jsonStructure.objects.length);
        jsonStructure.objects.forEach((obj, index) => {
            console.log(`  [${index}] Cr√©ation ${obj.type}:`, obj);
            let geometry;
            
            switch(obj.type) {
                case 'box':
                    geometry = new THREE.BoxGeometry(...obj.size);
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(obj.radius, 32, 32);
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(obj.radiusTop, obj.radiusBottom, obj.height, 32);
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(obj.size[0] / 2, obj.size[1], 32);
                    break;
                default:
                    geometry = new THREE.BoxGeometry(1, 1, 1);
            }
            
            const material = new THREE.MeshStandardMaterial({
                color: obj.color,
                metalness: 0.3,
                roughness: 0.7
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(...obj.position);
            mesh.rotation.set(...obj.rotation);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            console.log(`    ‚úì Mesh cr√©√©:`, mesh.position);
            group.add(mesh);
        });
        
        console.log('üë• Group cr√©√© avec', group.children.length, 'enfants');
        
        // Ajoute bras/jambes
        this.addLimbs(group);
        
        return group;
    }

    addLimbs(group) {
        const armLeft = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1, 0.1, 0.8),
            new THREE.MeshStandardMaterial({color: 0x4488FF})
        );
        armLeft.position.set(-0.5, 1.4, 0);
        armLeft.rotation.z = 0.3;
        group.add(armLeft);
        
        const armRight = armLeft.clone();
        armRight.position.set(0.5, 1.4, 0);
        armRight.rotation.z = -0.3;
        group.add(armRight);
        
        const legLeft = new THREE.Mesh(
            new THREE.CylinderGeometry(0.12, 0.12, 1.0),
            new THREE.MeshStandardMaterial({color: 0x333366})
        );
        legLeft.position.set(-0.2, 0.5, 0);
        group.add(legLeft);
        
        const legRight = legLeft.clone();
        legRight.position.set(0.2, 0.5, 0);
        group.add(legRight);
    }

    createCharacterDirectOLD(prompt) {
        // ANCIENNE VERSION - backup
        // ANCIENNE VERSION supprim√©e - maintenant on utilise JSON !
        return new THREE.Group();
    }

    executeAIGeneratedCode(code, name = 'Generated Object') {
        /**
         * EX√âCUTE le code JavaScript g√©n√©r√© par l'IA
         * Le code doit retourner un THREE.Object3D
         */
        try {
            console.log('üöÄ [AI-CODE] Ex√©cution du code IA...');
            console.log('üìù Code:', code);
            
            // Nettoie le code - enl√®ve le ; final qui emp√™che le return
            let cleanCode = code.trim();
            if (cleanCode.endsWith(';')) {
                cleanCode = cleanCode.slice(0, -1);
            }
            
            // S'assure que le code retourne l'objet
            if (!cleanCode.includes('return ')) {
                // Trouve le nom de la variable cr√©√©e (warrior, character, etc.)
                const varMatch = cleanCode.match(/const\s+(\w+)\s*=\s*new\s+THREE\.Group/);
                if (varMatch) {
                    const varName = varMatch[1];
                    cleanCode += `\nreturn ${varName};`;
                }
            }
            
            // √âvalue le code dans une fonction
            const func = new Function('THREE', cleanCode);
            const result = func(THREE);
            
            console.log('‚úÖ [AI-CODE] Code ex√©cut√©, r√©sultat:', result);
            
            if (result && (result.isObject3D || result.isGroup || result.isMesh)) {
                // Ajoute √† la sc√®ne
                result.userData.name = name;
                result.userData.aiGenerated = true;
                result.castShadow = true;
                result.receiveShadow = true;
                
                this.scene.add(result);
                this.objects.push(result);
                
                console.log('‚úÖ [AI-CODE] Objet ajout√© √† la sc√®ne:', result);
                console.log('   Objects dans la sc√®ne:', this.scene.children.length);
                
                return result;
            } else {
                console.error('‚ùå [AI-CODE] Le code ne retourne pas un objet THREE valide:', result);
                return null;
            }
            
        } catch (error) {
            console.error('‚ùå [AI-CODE] Erreur ex√©cution:', error);
            console.error('   Stack:', error.stack);
            return null;
        }
    }

    async loadOBJModel(meshPath, name = 'Generated Model') {
        return new Promise((resolve, reject) => {
            const loader = new THREE.OBJLoader();
            
            // Convertit le chemin absolu en chemin relatif pour le serveur web
            const relativePath = '/meshes/' + meshPath.split('/meshes/')[1];
            
            loader.load(
                relativePath,
                (object) => {
                    // Configure le mod√®le charg√©
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // Applique un mat√©riau par d√©faut si pas de mat√©riau
                            if (!child.material || !child.material.map) {
                                child.material = new THREE.MeshStandardMaterial({
                                    color: 0x4488ff,
                                    metalness: 0.3,
                                    roughness: 0.7
                                });
                            }
                        }
                    });
                    
                    // Centre et scale le mod√®le
                    const box = new THREE.Box3().setFromObject(object);
                    const center = box.getCenter(new THREE.Vector3());
                    object.position.sub(center);
                    object.position.y = box.max.y - box.min.y;
                    
                    // Ajoute √† la sc√®ne
                    object.userData.name = name;
                    this.scene.add(object);
                    this.objects.push(object);
                    
                    console.log('‚úÖ Mod√®le OBJ charg√©:', name);
                    resolve(object);
                },
                (xhr) => {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                    console.log(`Chargement OBJ: ${percent}%`);
                },
                (error) => {
                    console.error('Erreur chargement OBJ:', error);
                    reject(error);
                }
            );
        });
    }

    async createAnimationFromPromptKibali(prompt) {
        // Mode direct - pas besoin d'API
        console.log('üé¨ Animation directe:', prompt);
        this.createAnimationFromPrompt(prompt);
    }

    async controlCameraFromPromptKibali(prompt) {
        // Mode direct - pas besoin d'API
        console.log('üé• Contr√¥le cam√©ra direct:', prompt);
        this.controlCameraFromPrompt(prompt);
    }

    async createObjectFromPromptKibali(prompt) {
        try {
            const response = await fetch('http://localhost:5000/api/generate-model', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    prompt: prompt,
                    type: 'object',
                    method: 'procedural'
                })
            });

            const data = await response.json();
            
            if (data.success) {
                this.createObjectFromPrompt(prompt);
            }
        } catch (error) {
            console.error('Erreur Kibali object:', error);
            this.createObjectFromPrompt(prompt);
        }
    }

    applyAnimationKeyframes(keyframes) {
        // Applique les keyframes aux objets s√©lectionn√©s
        this.objects.forEach(obj => {
            if (obj.userData.type === 'character') {
                obj.userData.animation = {
                    type: 'keyframed',
                    keyframes: keyframes,
                    startFrame: this.currentFrame
                };
                
                // Ajoute √† la timeline
                keyframes.forEach(kf => {
                    this.addToTimeline('character', kf.frame);
                });
            }
        });
    }

    applyCameraPath(cameraPath) {
        // Applique le mouvement de cam√©ra
        if (cameraPath.type === 'orbit') {
            // Animation d'orbite
            const duration = cameraPath.duration;
            const startAngle = cameraPath.start_angle * Math.PI / 180;
            const endAngle = cameraPath.end_angle * Math.PI / 180;
            
            for (let frame = 0; frame < duration; frame += 10) {
                const progress = frame / duration;
                const angle = startAngle + (endAngle - startAngle) * progress;
                const x = cameraPath.center.x + cameraPath.radius * Math.cos(angle);
                const z = cameraPath.center.z + cameraPath.radius * Math.sin(angle);
                
                this.addToTimeline('camera', frame);
            }
        } else if (cameraPath.type === 'zoom') {
            // Animation de zoom
            this.addToTimeline('camera', 0);
            this.addToTimeline('camera', cameraPath.duration);
        }
    }

    createCharacterFromPrompt(prompt) {
        // Cr√©e un personnage basique (cube color√© pour l'instant)
        const geometry = new THREE.BoxGeometry(1, 2, 1);
        const material = new THREE.MeshStandardMaterial({ 
            color: Math.random() * 0xffffff,
            roughness: 0.5,
            metalness: 0.2
        });
        const character = new THREE.Mesh(geometry, material);
        character.position.set(
            (Math.random() - 0.5) * 5,
            1,
            (Math.random() - 0.5) * 5
        );
        character.castShadow = true;
        character.userData = { type: 'character', prompt };
        
        this.scene.add(character);
        this.objects.push(character);
        
        // Ajoute √† la timeline
        this.addToTimeline('character', 0);
    }

    createEnvironmentFromPrompt(prompt) {
        // Cr√©e un sol
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2d4059,
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.userData = { type: 'environment', prompt };
        
        this.scene.add(ground);
        this.objects.push(ground);
        
        // Ajoute quelques √©l√©ments al√©atoires
        for (let i = 0; i < 5; i++) {
            const size = 0.5 + Math.random();
            const cubeGeometry = new THREE.BoxGeometry(size, size * 2, size);
            const cubeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3d5a80
            });
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.set(
                (Math.random() - 0.5) * 15,
                size,
                (Math.random() - 0.5) * 15
            );
            cube.castShadow = true;
            this.scene.add(cube);
            this.objects.push(cube);
        }
        
        this.addToTimeline('environment', 0);
    }

    controlCameraFromPrompt(prompt) {
        const promptLower = prompt.toLowerCase();
        
        if (promptLower.includes('orbite') || promptLower.includes('orbit') || promptLower.includes('autour')) {
            // Vue orbite
            console.log('üé• Vue orbite');
            this.camera.position.set(10, 8, 10);
        } else if (promptLower.includes('haut') || promptLower.includes('top') || promptLower.includes('dessus')) {
            // Vue du dessus
            console.log('üé• Vue du dessus');
            this.camera.position.set(0, 20, 0);
        } else if (promptLower.includes('face') || promptLower.includes('front') || promptLower.includes('devant')) {
            // Vue de face
            console.log('üé• Vue de face');
            this.camera.position.set(0, 5, 15);
        } else if (promptLower.includes('c√¥t√©') || promptLower.includes('side') || promptLower.includes('profil')) {
            // Vue de c√¥t√©
            console.log('üé• Vue de c√¥t√©');
            this.camera.position.set(15, 5, 0);
        } else if (promptLower.includes('zoom') || promptLower.includes('proche') || promptLower.includes('pr√®s')) {
            // Zoom rapproch√©
            console.log('üé• Zoom rapproch√©');
            this.camera.position.set(3, 3, 3);
        } else if (promptLower.includes('loin') || promptLower.includes('large') || promptLower.includes('√©loign')) {
            // Vue √©loign√©e
            console.log('üé• Vue √©loign√©e');
            this.camera.position.set(20, 15, 20);
        } else if (promptLower.includes('cin√©ma') || promptLower.includes('cinema') || promptLower.includes('dramatique')) {
            // Vue cin√©matique
            console.log('üé• Vue cin√©matique');
            this.camera.position.set(8, 6, 12);
        } else {
            // Vue par d√©faut: 3/4
            console.log('üé• Vue 3/4 (d√©faut)');
            this.camera.position.set(8, 6, 8);
        }
        
        this.camera.lookAt(0, 2, 0);  // Regarde le centre √† hauteur de personnage
        this.addToTimeline('camera', this.currentFrame);
        
        console.log(`üìç Cam√©ra: (${this.camera.position.x.toFixed(1)}, ${this.camera.position.y.toFixed(1)}, ${this.camera.position.z.toFixed(1)})`);
    }

    createAnimationFromPrompt(prompt) {
        // Cr√©e une animation simple pour tous les personnages
        this.objects.forEach(obj => {
            if (obj.userData.type === 'character') {
                // Animation de rotation
                obj.userData.animation = {
                    type: 'rotation',
                    startFrame: this.currentFrame,
                    duration: 60
                };
            }
        });
        
        this.addToTimeline('animation', this.currentFrame);
    }

    addLightFromPrompt(prompt) {
        let light;
        
        if (prompt.includes('point')) {
            light = new THREE.PointLight(0xffffff, 1, 100);
            light.position.set(5, 5, 5);
        } else if (prompt.includes('spot')) {
            light = new THREE.SpotLight(0xffffff, 1);
            light.position.set(0, 10, 0);
        } else {
            light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(-5, 10, 5);
        }
        
        light.userData = { type: 'light', prompt };
        this.scene.add(light);
        this.objects.push(light);
    }

    createObjectFromPrompt(prompt) {
        let geometry;
        
        if (prompt.includes('sph√®re') || prompt.includes('sphere')) {
            geometry = new THREE.SphereGeometry(1, 32, 32);
        } else if (prompt.includes('cylindre') || prompt.includes('cylinder')) {
            geometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 32);
        } else {
            geometry = new THREE.BoxGeometry(1, 1, 1);
        }
        
        const material = new THREE.MeshStandardMaterial({ 
            color: Math.random() * 0xffffff
        });
        const object = new THREE.Mesh(geometry, material);
        object.position.set(
            (Math.random() - 0.5) * 5,
            1,
            (Math.random() - 0.5) * 5
        );
        object.castShadow = true;
        object.userData = { type: 'object', prompt };
        
        this.scene.add(object);
        this.objects.push(object);
    }

    addToTimeline(trackName, frame) {
        const trackId = `track-${trackName}`;
        const track = document.getElementById(trackId);
        
        if (track) {
            const keyframe = document.createElement('div');
            keyframe.className = 'keyframe';
            keyframe.style.left = ((frame / this.totalFrames) * 100) + '%';
            track.appendChild(keyframe);
        }
    }

    updateObjectCount() {
        document.getElementById('object-count').textContent = this.objects.length;
    }

    focusOnObject(object) {
        /**
         * Centre la cam√©ra sur un objet
         */
        console.log('üé• Focus cam√©ra sur l\'objet...');
        
        // Calcule le centre de l'objet
        const box = new THREE.Box3().setFromObject(object);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        
        console.log(`   - Centre: ${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)}`);
        console.log(`   - Taille: ${size.x.toFixed(2)}, ${size.y.toFixed(2)}, ${size.z.toFixed(2)}`);
        
        // Distance optimale (d√©pend de la taille)
        const maxDim = Math.max(size.x, size.y, size.z);
        const distance = maxDim * 3;
        
        // Positionne la cam√©ra
        this.camera.position.set(
            center.x + distance,
            center.y + distance * 0.7,
            center.z + distance
        );
        this.camera.lookAt(center);
        
        console.log(`   - Nouvelle position cam√©ra: ${this.camera.position.x.toFixed(2)}, ${this.camera.position.y.toFixed(2)}, ${this.camera.position.z.toFixed(2)}`);
    }

    togglePlayback() {
        this.isPlaying = !this.isPlaying;
        const playBtn = document.querySelector('.play-btn');
        playBtn.textContent = this.isPlaying ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
    }

    setView(view) {
        switch(view) {
            case 'front':
                this.camera.position.set(0, 5, 15);
                break;
            case 'side':
                this.camera.position.set(15, 5, 0);
                break;
            case 'top':
                this.camera.position.set(0, 20, 0);
                break;
        }
        this.camera.lookAt(0, 0, 0);
    }

    resetView() {
        this.camera.position.set(5, 5, 5);
        this.camera.lookAt(0, 0, 0);
    }
}

// UI Functions
function addChatMessage(type, message) {
    const messagesContainer = document.getElementById('chat-messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}`;
    
    const now = new Date();
    const time = now.getHours() + ':' + String(now.getMinutes()).padStart(2, '0');
    
    messageDiv.innerHTML = `
        <div>${message}</div>
        <div class="message-time">${time}</div>
    `;
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
    
    return messageDiv; // Retourne l'√©l√©ment pour pouvoir le supprimer si n√©cessaire
}

function handleChatInput(event) {
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        const input = document.getElementById('chat-input');
        const message = input.value.trim();
        
        if (message) {
            studio.processAICommand(message);
            input.value = '';
        }
    }
}

function quickPrompt(prompt) {
    const input = document.getElementById('chat-input');
    input.value = prompt;
    input.focus();
}

function aiPrompt(defaultText) {
    const input = document.getElementById('chat-input');
    input.value = defaultText;
    input.focus();
}

function togglePlayback() {
    studio.togglePlayback();
}

function seekTimeline(event) {
    const slider = event.currentTarget;
    const rect = slider.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const percentage = x / rect.width;
    studio.currentFrame = Math.floor(percentage * studio.totalFrames);
    studio.updateFrame();
}

function setView(view) {
    studio.setView(view);
}

function resetView() {
    studio.resetView();
}

function saveProject() {
    const project = {
        objects: studio.objects.map(obj => ({
            type: obj.userData.type,
            prompt: obj.userData.prompt,
            position: obj.position,
            rotation: obj.rotation,
            scale: obj.scale
        })),
        camera: {
            position: studio.camera.position,
            rotation: studio.camera.rotation
        },
        currentFrame: studio.currentFrame
    };
    
    const json = JSON.stringify(project, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'kibalone-project.json';
    a.click();
    
    addChatMessage('ai', 'üíæ Projet sauvegard√© !');
}

function exportScene() {
    addChatMessage('ai', 'üì§ Export en cours... Format OBJ g√©n√©r√© !');
    // TODO: Impl√©menter export r√©el
}

function renderVideo() {
    addChatMessage('ai', 'üé¨ Rendu vid√©o d√©marr√© ! Cela peut prendre quelques minutes...');
    // TODO: Impl√©menter rendu vid√©o
}

// Initialize
let studio;

// Redirection des console.log vers la console UI
const originalConsoleLog = console.log;
const originalConsoleError = console.error;
const originalConsoleWarn = console.warn;

function addLogToUI(message, type = 'log') {
    const logDiv = document.getElementById('console-logs');
    if (!logDiv) return;
    
    const timestamp = new Date().toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
    const logEntry = document.createElement('div');
    
    let color = '#a0a0a0';
    let icon = '‚Ä¢';
    
    if (type === 'error') {
        color = '#ff4444';
        icon = '‚ùå';
    } else if (type === 'warn') {
        color = '#ffaa00';
        icon = '‚ö†Ô∏è';
    } else if (message.includes('‚úÖ') || message.includes('SUCCESS')) {
        color = '#00ff88';
        icon = '‚úÖ';
    } else if (message.includes('üöÄ') || message.includes('Cr√©ation')) {
        color = '#00d4ff';
        icon = 'üöÄ';
    } else if (message.includes('üìã') || message.includes('JSON')) {
        color = '#ff88ff';
        icon = 'üìã';
    }
    
    logEntry.style.color = color;
    logEntry.style.marginBottom = '3px';
    logEntry.innerHTML = `<span style="color: #666;">[${timestamp}]</span> ${icon} ${message}`;
    
    logDiv.appendChild(logEntry);
    logDiv.scrollTop = logDiv.scrollHeight;
    
    // Limite √† 200 lignes
    while (logDiv.children.length > 200) {
        logDiv.removeChild(logDiv.firstChild);
    }
}

console.log = function(...args) {
    originalConsoleLog.apply(console, args);
    addLogToUI(args.join(' '), 'log');
};

console.error = function(...args) {
    originalConsoleError.apply(console, args);
    addLogToUI(args.join(' '), 'error');
};

console.warn = function(...args) {
    originalConsoleWarn.apply(console, args);
    addLogToUI(args.join(' '), 'warn');
};

function clearLogs() {
    const logDiv = document.getElementById('console-logs');
    if (logDiv) {
        logDiv.innerHTML = '';
        console.log('Console vid√©e');
    }
}

window.addEventListener('DOMContentLoaded', () => {
    console.log('üé¨ Initialisation Kibalone Studio...');
    studio = new KibaloneStudio();
    
    // Message de bienvenue
    setTimeout(() => {
        addChatMessage('ai', 'üí° Astuce: Essayez "Cr√©e un personnage h√©ro√Øque" ou "Environnement for√™t magique"');
    }, 2000);
});

// ============================================================================
// RECONSTRUCTION 3D MULTI-VUES - IA KIBALI
// ============================================================================

let reconstructionSession = null;
let reconstructionImages = [];

/**
 * Ouvre le s√©lecteur d'images multiples pour reconstruction 3D
 */
function openMultiImageReconstruction() {
    console.log('üì∑ Ouverture du s√©lecteur multi-images...');
    addChatMessage('ai', 'üì∏ S√©lectionnez plusieurs images de votre objet prises sous diff√©rents angles (minimum 4-8 images recommand√©).');
    document.getElementById('multiImageInput').click();
}

/**
 * G√®re l'upload de plusieurs images et lance la reconstruction
 */
async function handleMultiImageUpload(event) {
    const files = Array.from(event.target.files);
    
    if (files.length < 3) {
        addChatMessage('ai', '‚ö†Ô∏è Veuillez s√©lectionner au moins 3 images pour une reconstruction de qualit√©.');
        console.warn('Pas assez d\'images s√©lectionn√©es:', files.length);
        return;
    }
    
    console.log(`üì∏ ${files.length} images s√©lectionn√©es pour reconstruction`);
    addChatMessage('ai', `‚úÖ ${files.length} images re√ßues. Kibali lance la reconstruction 3D multi-vues...`);
    
    try {
        // √âtape 1: Cr√©er une session de reconstruction
        console.log('üîß Cr√©ation de la session de reconstruction...');
        const sessionResponse = await fetch('http://localhost:5002/api/create_session', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                preset: 'photogrammetry'
            })
        });
        
        if (!sessionResponse.ok) {
            throw new Error(`Erreur session: ${sessionResponse.statusText}`);
        }
        
        const sessionData = await sessionResponse.json();
        reconstructionSession = sessionData.session_id;
        console.log('‚úÖ Session cr√©√©e:', reconstructionSession);
        addChatMessage('ai', `üîó Session Kibali cr√©√©e (${reconstructionSession.substring(0, 8)})`);
        
        // √âtape 2: Uploader et fusionner chaque image
        console.log('üì§ Upload et fusion des images...');
        addChatMessage('ai', 'üîÑ Analyse et fusion des images en cours...');
        
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const formData = new FormData();
            formData.append('file', file);
            formData.append('session_id', reconstructionSession);
            
            console.log(`üì∏ Traitement image ${i + 1}/${files.length}: ${file.name}`);
            
            const uploadResponse = await fetch('http://localhost:5002/api/upload_scan', {
                method: 'POST',
                body: formData
            });
            
            if (!uploadResponse.ok) {
                throw new Error(`Erreur upload image ${i + 1}: ${uploadResponse.statusText}`);
            }
            
            const uploadData = await uploadResponse.json();
            console.log(`‚úÖ Image ${i + 1} fusionn√©e:`, uploadData);
            
            // Mise √† jour de la progression
            const progress = Math.round(((i + 1) / files.length) * 100);
            addChatMessage('ai', `‚è≥ ${progress}% ‚Ä¢ Image ${i + 1}/${files.length} ‚Ä¢ ${uploadData.total_points.toLocaleString()} points ‚Ä¢ fitness ${uploadData.fitness.toFixed(2)}`);
        }
        
        // √âtape 3: G√©n√©rer le mesh final
        console.log('üé® G√©n√©ration du mesh 3D...');
        addChatMessage('ai', 'üé® G√©n√©ration du mesh 3D final...');
        
        const meshResponse = await fetch('http://localhost:5002/api/generate_mesh', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                session_id: reconstructionSession
            })
        });
        
        if (!meshResponse.ok) {
            throw new Error(`Erreur g√©n√©ration mesh: ${meshResponse.statusText}`);
        }
        
        const meshData = await meshResponse.json();
        console.log('‚úÖ Mesh g√©n√©r√©:', meshData);
        
        addChatMessage('ai', `‚úÖ Reconstruction termin√©e!\n` +
            `üìä Sommets: ${meshData.vertices.toLocaleString()}\n` +
            `üìê Faces: ${meshData.faces.toLocaleString()}\n` +
            `üéâ Affichage dans la sc√®ne...`
        );
        
        // √âtape 4: T√©l√©charger et charger le mesh dans la sc√®ne
        console.log('üé¨ Chargement du mod√®le dans la sc√®ne...');
        const downloadResponse = await fetch(`http://localhost:5002/api/download_mesh/${reconstructionSession}`);
        
        if (downloadResponse.ok) {
            const meshBlob = await downloadResponse.blob();
            const meshUrl = URL.createObjectURL(meshBlob);
            
            // Charger dans la sc√®ne Three.js
            await loadPLYIntoScene(meshUrl, `reconstruction_${Date.now()}`);
            
            addChatMessage('ai', 'üéâ Mod√®le 3D charg√© dans la sc√®ne !\n\n' +
                'üí° Vous pouvez maintenant:\n' +
                '   ‚Ä¢ Tourner avec la souris\n' +
                '   ‚Ä¢ Zoomer avec la molette\n' +
                '   ‚Ä¢ Animer, texturer, exporter...'
            );
        }
        
        // Nettoyage
        setTimeout(() => {
            deleteReconstructionSession(reconstructionSession);
        }, 5000);
        
    } catch (error) {
        console.error('‚ùå Erreur reconstruction:', error);
        addChatMessage('ai', `‚ùå Erreur Kibali: ${error.message}\n\n` +
            'V√©rifiez que le service de reconstruction est d√©marr√©.'
        );
        
        if (reconstructionSession) {
            deleteReconstructionSession(reconstructionSession);
        }
    } finally {
        // R√©initialiser l'input
        event.target.value = '';
    }
}
        
        // √âtape 4: T√©l√©charger le nuage de points fusionn√©
        console.log('üíæ T√©l√©chargement du nuage fusionn√©...');
        addChatMessage('ai', '‚è≥ G√©n√©ration du fichier PLY...');
        
        const cloudResponse = await fetch(`http://localhost:5002/api/get_fused_cloud/${reconstructionSession}`);
        const cloudBlob = await cloudResponse.blob();
        const cloudUrl = URL.createObjectURL(cloudBlob);
        
        // T√©l√©chargement automatique
        const a = document.createElement('a');
        a.href = cloudUrl;
        a.download = `reconstruction_${Date.now()}.ply`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        console.log('‚úÖ Nuage de points t√©l√©charg√©');
        addChatMessage('ai', 'üíæ Nuage de points sauvegard√© !');
        
        // √âtape 5: G√©n√©rer et t√©l√©charger le mesh
        console.log('üé® G√©n√©ration du mesh 3D...');
        addChatMessage('ai', 'üé® G√©n√©ration du mesh 3D (Poisson)...');
        
        const meshResponse = await fetch(`http://localhost:5002/api/get_mesh/${reconstructionSession}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                method: 'poisson',
                poisson_depth: 9
            })
        });
        
        if (meshResponse.ok) {
            const meshBlob = await meshResponse.blob();
            const meshUrl = URL.createObjectURL(meshBlob);
            
            const meshLink = document.createElement('a');
            meshLink.href = meshUrl;
            meshLink.download = `mesh_${Date.now()}.ply`;
            document.body.appendChild(meshLink);
            meshLink.click();
            document.body.removeChild(meshLink);
            
            console.log('‚úÖ Mesh 3D t√©l√©charg√©');
            addChatMessage('ai', 'üéâ Mesh 3D g√©n√©r√© et sauvegard√© !\n\n' +
                'üìÅ Fichiers cr√©√©s:\n' +
                '   ‚Ä¢ reconstruction_xxxxx.ply (nuage de points)\n' +
                '   ‚Ä¢ mesh_xxxxx.ply (mesh triangulaire)\n\n' +
                'üí° Ouvrez-les avec MeshLab ou Blender!'
            );
        } else {
            console.warn('Mesh non g√©n√©r√© (possible si pas assez de scans)');
            addChatMessage('ai', '‚ö†Ô∏è Mesh non g√©n√©r√©. Essayez avec plus d\'images pour un meilleur r√©sultat.');
        }
        
        // √âtape 6: Charger le mod√®le dans la sc√®ne Three.js
        console.log('üé¨ Chargement du mod√®le dans la sc√®ne...');
        await loadPLYModelIntoScene(cloudUrl);
        
        // Nettoyage
        setTimeout(() => {
            deleteReconstructionSession(reconstructionSession);
        }, 5000);
        
    } catch (error) {
        console.error('‚ùå Erreur reconstruction:', error);
        addChatMessage('ai', `‚ùå Erreur: ${error.message}\n\n` +
            'V√©rifiez que l\'API MiDaS Multi-View est d√©marr√©e:\n' +
            '   ./start_kibalone_full.sh'
        );
        
        if (reconstructionSession) {
            deleteReconstructionSession(reconstructionSession);
        }
    } finally {
        // R√©initialiser l'input
        event.target.value = '';
    }
}

/**
 * Charge un fichier PLY dans la sc√®ne Three.js
 */
async function loadPLYModelIntoScene(plyUrl) {
    try {
        console.log('üé¨ Chargement du mod√®le PLY dans Three.js...');
        
        // Note: Three.js n√©cessite un loader PLY
        // Pour l'instant, on affiche un message
        addChatMessage('ai', 'üé¨ Mod√®le 3D pr√™t ! Pour visualiser:\n' +
            '   1. Ouvrez le fichier PLY avec MeshLab\n' +
            '   2. Ou importez-le dans Blender\n' +
            '   3. Ou utilisez CloudCompare'
        );
        
        console.log('‚úÖ Processus de reconstruction termin√©');
        
    } catch (error) {
        console.error('Erreur chargement PLY:', error);
    }
}

/**
 * Supprime une session de reconstruction
 */
async function deleteReconstructionSession(sessionId) {
    try {
        await fetch(`http://localhost:5002/api/delete_session/${sessionId}`, {
            method: 'DELETE'
        });
        console.log('üóëÔ∏è Session de reconstruction supprim√©e:', sessionId);
    } catch (error) {
        console.error('Erreur suppression session:', error);
    }
}

// Ajouter un raccourci pour tester rapidement
function testMultiViewReconstruction() {
    console.log('üß™ Mode test: Ouvrez le s√©lecteur et choisissez 5-10 photos');
    addChatMessage('ai', 'üß™ TEST MODE: S√©lectionnez 5-10 photos de votre objet sous diff√©rents angles (tous les 30-45¬∞)');
    openMultiImageReconstruction();
}

/**
 * Ouvre le s√©lecteur de fichiers PLY
 */
function openPLYLoader() {
    const input = document.getElementById('plyFileInput');
    if (input) {
        input.click();
    }
}

/**
 * G√®re l'upload de fichiers PLY
 */
async function handlePLYUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    console.log('üìÇ Chargement fichier PLY:', file.name);
    addChatMessage('ai', `üìÇ Chargement de ${file.name}...`);
    
    try {
        const url = URL.createObjectURL(file);
        await loadPLYIntoScene(url, file.name);
        
        addChatMessage('ai', `‚úÖ Mod√®le ${file.name} charg√© dans la sc√®ne !\n\n` +
            'üí° Utilisez la souris pour:\n' +
            '   ‚Ä¢ Orbiter (clic gauche + glisser)\n' +
            '   ‚Ä¢ Zoomer (molette)\n' +
            '   ‚Ä¢ D√©placer (clic droit + glisser)'
        );
        
        // Ajouter √† la liste des fichiers
        updateFilesList(file.name, file.size);
        
    } catch (error) {
        console.error('‚ùå Erreur chargement PLY:', error);
        addChatMessage('ai', `‚ùå Erreur lors du chargement: ${error.message}`);
    } finally {
        event.target.value = '';
    }
}

/**
 * Charge un fichier PLY dans la sc√®ne Three.js
 */
async function loadPLYIntoScene(url, name) {
    return new Promise((resolve, reject) => {
        if (!THREE.PLYLoader) {
            reject(new Error('PLYLoader non disponible. V√©rifiez que le script est charg√©.'));
            return;
        }
        
        const loader = new THREE.PLYLoader();
        
        loader.load(url, (geometry) => {
            try {
                console.log('üé® Cr√©ation du mat√©riau...');
                
                // Calculer les normales si n√©cessaire
                if (!geometry.attributes.normal) {
                    geometry.computeVertexNormals();
                }
                
                // Cr√©er le mat√©riau
                const material = new THREE.PointsMaterial({
                    size: 0.01,
                    vertexColors: geometry.attributes.color ? true : false,
                    color: geometry.attributes.color ? 0xffffff : 0x00aaff
                });
                
                // Cr√©er le nuage de points
                const pointCloud = new THREE.Points(geometry, material);
                pointCloud.userData.name = name;
                pointCloud.userData.isReconstruction = true;
                
                // Centrer le mod√®le
                geometry.computeBoundingBox();
                const bbox = geometry.boundingBox;
                const center = new THREE.Vector3();
                bbox.getCenter(center);
                pointCloud.position.sub(center);
                
                // Ajuster l'√©chelle si n√©cessaire
                const size = bbox.getSize(new THREE.Vector3()).length();
                if (size > 10) {
                    const scale = 10 / size;
                    pointCloud.scale.setScalar(scale);
                }
                
                // Ajouter √† la sc√®ne
                studio.scene.add(pointCloud);
                studio.objects.push(pointCloud);
                
                console.log(`‚úÖ Mod√®le ${name} ajout√©:`, {
                    vertices: geometry.attributes.position.count,
                    hasColors: !!geometry.attributes.color,
                    bbox: bbox
                });
                
                // Ajuster la cam√©ra
                studio.camera.position.set(0, 2, 5);
                studio.camera.lookAt(0, 0, 0);
                
                resolve(pointCloud);
                
            } catch (error) {
                reject(error);
            }
        }, 
        (progress) => {
            const percent = (progress.loaded / progress.total * 100).toFixed(0);
            console.log(`üì• Chargement: ${percent}%`);
        },
        (error) => {
            reject(error);
        });
    });
}

/**
 * Charge automatiquement la reconstruction de test au d√©marrage
 */
async function loadTestReconstruction() {
    try {
        console.log('üß™ Chargement reconstruction test ch√¢teau...');
        addChatMessage('ai', 'üß™ Chargement de la reconstruction test...');
        
        const response = await fetch('http://localhost:5002/api/test_reconstruction');
        if (!response.ok) {
            throw new Error('Fichier test non trouv√©');
        }
        
        const blob = await response.blob();
        const url = URL.createObjectURL(blob);
        
        await loadPLYIntoScene(url, 'chateau_test.ply');
        
        addChatMessage('ai', '‚úÖ Reconstruction test charg√©e !\n\n' +
            'üè∞ Mod√®le: Ch√¢teau (5 angles)\n' +
            'üìä 88,737 points fusionn√©s\n' +
            'üí° Essayez maintenant avec vos propres images !'
        );
        
        updateFilesList('chateau_test.ply', 22000000); // 22MB
        
    } catch (error) {
        console.warn('‚ö†Ô∏è Reconstruction test non disponible:', error.message);
        // Ne pas afficher d'erreur √† l'utilisateur si le fichier n'existe pas
    }
}

/**
 * Met √† jour la liste des fichiers charg√©s
 */
function updateFilesList(filename, size) {
    const filesList = document.getElementById('filesList');
    if (!filesList) return;
    
    const sizeStr = (size / 1024 / 1024).toFixed(2) + ' MB';
    const fileItem = document.createElement('div');
    fileItem.style.padding = '5px';
    fileItem.style.borderBottom = '1px solid #333';
    fileItem.innerHTML = `
        <div style="color: #0ff; font-weight: bold;">üìÑ ${filename}</div>
        <div style="color: #888; font-size: 10px;">${sizeStr}</div>
    `;
    
    filesList.appendChild(fileItem);
}

/**
 * Met √† jour l'affichage de l'objet s√©lectionn√©
 */
function updateSelectionInfo(object) {
    const selectionInfo = document.getElementById('selectionInfo');
    if (!selectionInfo) return;
    
    if (!object) {
        selectionInfo.innerHTML = 'Cliquez sur un objet pour le s√©lectionner';
        selectionInfo.style.color = '#888';
        return;
    }
    
    const name = object.userData.name || 'Objet sans nom';
    const type = object.type || 'Unknown';
    let vertices = 0;
    
    if (object.geometry && object.geometry.attributes.position) {
        vertices = object.geometry.attributes.position.count;
    }
    
    selectionInfo.innerHTML = `
        <div style="color: #00ff88; font-weight: bold;">‚úÖ ${name}</div>
        <div style="color: #aaa; font-size: 10px; margin-top: 4px;">
            Type: ${type}<br>
            Vertices: ${vertices.toLocaleString()}
        </div>
    `;
    selectionInfo.style.color = '#0ff';
}

/**
 * Lance le test de reconstruction automatique avec les images du dossier test_images
 */
async function runTestReconstruction() {
    try {
        console.log('üß™ Lancement du test de reconstruction automatique...');
        addChatMessage('user', 'Lance une reconstruction 3D test avec les images du ch√¢teau');
        addChatMessage('ai', 'ü§ñ Compris ! Je lance la reconstruction 3D avec les images de test...\n\n‚è≥ Chargement des images du dossier test_images/');
        
        // Simuler le chargement des images depuis le serveur
        const testImages = [
            'test_images/image_01.jpg',
            'test_images/image_02.jpg',
            'test_images/image_03.jpg',
            'test_images/image_04.jpg',
            'test_images/image_05.jpg'
        ];
        
        // Cr√©er une session
        const sessionResponse = await fetch('http://localhost:5002/api/create_session', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ preset: 'photogrammetry' })
        });
        
        if (!sessionResponse.ok) {
            throw new Error('Erreur cr√©ation session');
        }
        
        const sessionData = await sessionResponse.json();
        const sessionId = sessionData.session_id;
        
        console.log('‚úÖ Session cr√©√©e:', sessionId);
        addChatMessage('ai', `üì∏ Session cr√©√©e: ${sessionId}\n‚è≥ Upload des images...`);
        
        // Upload chaque image
        for (let i = 0; i < testImages.length; i++) {
            const imgPath = testImages[i];
            console.log(`üì§ Upload image ${i + 1}/${testImages.length}: ${imgPath}`);
            
            // Charger l'image depuis le serveur
            const imgResponse = await fetch(`http://localhost:8080/${imgPath}`);
            const imgBlob = await imgResponse.blob();
            
            // Cr√©er FormData
            const formData = new FormData();
            formData.append('image', imgBlob, `test_${i + 1}.jpg`);
            formData.append('session_id', sessionId);
            
            // Upload
            const uploadResponse = await fetch('http://localhost:5002/api/upload_scan', {
                method: 'POST',
                body: formData
            });
            
            if (!uploadResponse.ok) {
                throw new Error(`Erreur upload image ${i + 1}`);
            }
            
            addChatMessage('ai', `‚úÖ Image ${i + 1}/${testImages.length} trait√©e`);
        }
        
        // G√©n√©rer le mesh
        console.log('üé® G√©n√©ration du mesh 3D...');
        addChatMessage('ai', 'üé® Fusion des scans et g√©n√©ration du mesh 3D...');
        
        const meshResponse = await fetch('http://localhost:5002/api/generate_mesh', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ session_id: sessionId })
        });
        
        if (!meshResponse.ok) {
            throw new Error('Erreur g√©n√©ration mesh');
        }
        
        const meshData = await meshResponse.json();
        console.log('‚úÖ Mesh g√©n√©r√©:', meshData);
        
        addChatMessage('ai', `‚úÖ Reconstruction termin√©e!\nüìä Vertices: ${meshData.vertices.toLocaleString()}\nüìê Faces: ${meshData.faces.toLocaleString()}\nüéâ Chargement dans la sc√®ne...`);
        
        // T√©l√©charger et charger le mesh
        const downloadResponse = await fetch(`http://localhost:5002/api/download_mesh/${sessionId}`);
        
        if (downloadResponse.ok) {
            const meshBlob = await downloadResponse.blob();
            const meshUrl = URL.createObjectURL(meshBlob);
            
            // Charger dans la sc√®ne
            await loadPLYIntoScene(meshUrl, `test_reconstruction_${Date.now()}.ply`);
            
            addChatMessage('ai', 'üéâ Reconstruction test charg√©e dans la sc√®ne !\n\nüí° Vous pouvez maintenant:\n   ‚Ä¢ Tourner avec la souris\n   ‚Ä¢ Zoomer avec la molette\n   ‚Ä¢ Cliquer pour s√©lectionner\n   ‚Ä¢ Supprimer avec le bouton üóëÔ∏è');
        }
        
        // Nettoyage
        setTimeout(() => {
            fetch(`http://localhost:5002/api/delete_session/${sessionId}`, { method: 'DELETE' });
        }, 5000);
        
    } catch (error) {
        console.error('‚ùå Erreur test reconstruction:', error);
        addChatMessage('ai', `‚ùå Erreur: ${error.message}\n\nV√©rifiez que les services sont d√©marr√©s:\n   ./start_kibalone_full.sh`);
    }
}

console.log('‚úÖ Module de reconstruction 3D multi-vues charg√©');


