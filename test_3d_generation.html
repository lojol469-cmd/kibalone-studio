<!DOCTYPE html>
<html>
<head>
    <title>Test GÃ©nÃ©ration 3D</title>
    <style>
        body { margin: 0; background: #1a1a2e; font-family: Arial; }
        canvas { width: 100%; height: 100vh; display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            background: #00d4ff;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover { background: #00a8cc; }
    </style>
</head>
<body>
    <div id="info">
        <h3>ğŸ¨ Test GÃ©nÃ©ration 3D</h3>
        <button onclick="testWarrior()">âš”ï¸ Guerrier</button>
        <button onclick="testRobot()">ğŸ¤– Robot</button>
        <button onclick="testCreature()">ğŸ‰ Dragon</button>
        <button onclick="testHuman()">ğŸ‘¤ Humain</button>
        <button onclick="clearScene()">ğŸ—‘ï¸ Clear</button>
        <div id="stats" style="margin-top: 10px; color: #00d4ff;"></div>
    </div>
    <canvas id="canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, objects = [];

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f0f1e);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 2, 0);

            // Renderer
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;

            // Lights
            const ambient = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambient);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 15, 10);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // Grid
            const grid = new THREE.GridHelper(20, 20, 0x00d4ff, 0x2d4059);
            scene.add(grid);

            // Axes
            const axes = new THREE.AxesHelper(5);
            scene.add(axes);

            animate();
            updateStats();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Rotation automatique des objets
            objects.forEach(obj => {
                if (obj.userData.rotate) {
                    obj.rotation.y += 0.01;
                }
            });
            
            renderer.render(scene, camera);
        }

        function updateStats() {
            document.getElementById('stats').innerHTML = `
                ğŸ“Š Objets: ${objects.length}<br>
                ğŸ¯ Scene: ${scene.children.length} enfants
            `;
        }

        async function testWarrior() {
            console.log('âš”ï¸ Test guerrier...');
            await createModel('warrior');
        }

        async function testRobot() {
            console.log('ğŸ¤– Test robot...');
            await createModel('robot');
        }

        async function testCreature() {
            console.log('ğŸ‰ Test crÃ©ature...');
            await createModel('dragon');
        }

        async function testHuman() {
            console.log('ğŸ‘¤ Test humain...');
            await createModel('human character');
        }

        async function createModel(prompt) {
            try {
                const response = await fetch('http://localhost:5001/api/text-to-3d-triposr', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ prompt })
                });

                const data = await response.json();

                if (data.success && data.code) {
                    console.log('âœ… ModÃ¨le reÃ§u:', data.model_type);
                    console.log('   Vertices:', data.vertices_count);
                    console.log('   Faces:', data.faces_count);

                    // ExÃ©cute le code
                    const model = eval(data.code);

                    if (model) {
                        // Position alÃ©atoire
                        const x = (Math.random() - 0.5) * 10;
                        const z = (Math.random() - 0.5) * 10;
                        model.position.set(x, 0, z);
                        model.userData.rotate = true;

                        scene.add(model);
                        objects.push(model);
                        updateStats();

                        console.log('âœ… ModÃ¨le ajoutÃ© Ã  la scÃ¨ne!');
                        console.log('   Position:', model.position);
                    } else {
                        console.error('âŒ ModÃ¨le null');
                    }
                } else {
                    console.error('âŒ Erreur API:', data.error);
                }
            } catch (error) {
                console.error('âŒ Erreur:', error);
            }
        }

        function clearScene() {
            objects.forEach(obj => scene.remove(obj));
            objects = [];
            updateStats();
            console.log('ğŸ—‘ï¸ ScÃ¨ne nettoyÃ©e');
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
